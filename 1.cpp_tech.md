# CPP 编程常用技术

1. ＃include＜＞与＃include”” 的区别是：
    ＃include＜＞常用来包含系统提供的头文件，编译器会到保存系统标准头文件的位置查找头文件；
    ＃include””常用于包括程序员自己编号的头文件，用这种格式时，编译器先查找当前目录是否有指定名称的头文件，然后从标准头目录中进行查找 。

2. ＃include<iostream＞和 #include<iostream.h＞的使用 
    事实上， #include<iostream>和＃include<iostream.h＞是不一样的，因为 iostream 和 iostream.h 是两个不同的文件，前者没有后缀 。 实际上，在你的编译器 include 文件夹里面可以看到，两个文件打开后，里面的代
    码是不一样的 。 后缀为 .h 的头文件在 C＋＋标准已经明确提出不再支持了，早些的 C 语言为
    了实现将标准库功能定义在全局空间里，声明放在在带 h 后缀的头文件里 。 C＋＋标准为了
    和 C 语言区别开，也为了正确使用命名空间，规定头文件不再使用后缀 .h 。 因此，当使用
    <iostream.h＞时 ，相当于在 C 中调用库函数，使用的是全局命名 空间，也就是早期的 C＋＋实
    现方法 。 换句话说， iostream 是 iostream.h 的升级版，大部分的头文件都有一个不带 .h 扩展
    名的文件与之相对应 。 不过有个特例，＜string＞并非＜s位ing.h＞的升级版。

3. 函数重载
    Cpp 允许用同一函数名定义多个函数，但这些函数必须参数个数不同或类型不 同，这就是函数重载

4. 函数模板
    函数模板，实际上是建立一个通用函数，其函数类型和形参不具体指定，而用一个虚拟
    的类型来代表，这个通用函数就是函数模板。

    定义函数模板的一般格式是：
        template<typename T>

5. strlen 与 sizeof 的 区别如下所示 ：

    1) strlen（）是函数，在运行时才能计算 。 参数必须是字符型指针（ char叫，且必须是
    以’＼0’结尾的 。 当数组名作为参数传入时，实际上数组已 经退化为指针了 。 它的功能是返回
    字符串 的长度 。

    2) sizeof（）是运算符，而不是一个函数，在编译时就计算好了，用于计算数据空间的字
    节数。 因此， sizeof 不能用来返回动态分配的内存空间的大小 。 sizeof 常用于返回类型和静态
    分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系 。

6. 数组与指针
    在 Cpp 中 ， 数组名代表数组第一个元素的地址
    1） 数组指针，也称行指针，定义 int (*p)[n］；且（）优先级高，首先说明 p 是一个指针，且指向一个整型的一维数组

    2） 指针数组不同于数组指针, 定义 int 与［n］；且[]优先级高，可以理解为先与 p 结合成为一个数组，再由 int地区说明这是一个整型指针数组 ， 它有 n 个指针类型的数组元素

    优先级 ：() > [] > *

7. 字符串与指针
    1 ）字符串指针变量本身是一个变量，用于存放字符串的首地址。
    2 ）字符串本身是存放在以该首地址为首的一块连续的内存空间中，并以'\0'作为字符串的结束标函
    3 ）字符数组是由于若干个数组元素组成的，每个元素中存放字符串的一个字符。 在定义一个字符数组时，编译后就会分配一个内存单元，每个元素都有确定的地址 。

8. 函数与指针
    函数指针是指向函数的指针变量

    函数指针的声明方法是：
        返回值类型（＊指针变量名）（［形参列表］） ；

9. 引用
    1) 是一种变量类型，它用于为一个变量起一个别名 。

        引用的声明方法是 ：
            类型标识符＆引用名＝目标变量名 ；

        int a ;
        int &r=a ;

        定义引用 r，它是变量 a 的引用，即别名 。经过这样的声明后， a 和 r 的作用都一样，都
        代表着同一变量。 a 和 r 占用内存的同一个存储单元，即具有同一地址。 在声明一个引用变
        量时，必须同时使之初始化，即声明它代表哪个变量 。 函数执行期间，不可以将其再作为其
        他变量的引用 。

    2) 引用作为参数
        引用一个重要的作用就是作为函数的参数
        使用引用传递函数的参数时，在内存中并没有产生实参的副本，而是对实参直接操作 。
        当使用一般变盘传递函数的参数时，当函数发生调用，需要给形参分配存储单元，形参变量
        是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率更高，所占空间更少 。

        使用指针作为函数的参数虽然也能达到与使用引用同样的效果，但是在被调函数中同样
        要给形参分配存储单元，且需要重复使用“＊指针变量名”的形式进行运算，这很容易产生
        错误且程序的阅读性较差 ；另一方面，在主调函数的调用点处，必须用变量的地址作为实参 ，
        这些都不太方便。

        引用是个有效率的选择

    3) 常引用
        如果既要提高程序的效率，又要使传递给函数的数据不在函数中被改变，就应该使用常
        引用 。 常引用的声明方式是：
            const 类型标识符＆ 引 用名＝目标变量名 ；

        用这种方式声明的引用，不能通过引用对目标变量的值进行修改，在程序中使引用的目
        标成为 const 类型，从而保证了引用的安全性下

        ```c
        int a ;
        const i nt &r=a ;
        r = 1; // 错误
        a = 1; // 正确
        // 假设有如下函数声明：
        string funcl();
        void func2(string &s);
        // 那么下面的表达式都是非法的：
        func2(funcl);
        func2( "hello ” ) ;
        // 原因在于funcl()和”hello”都将产生一个临时对象，而在 C＋＋中，这些临时对象都是
        // const 类型的, 因此，上面的表达式就是试图将一个 const 类型的对象转化为非 const 类型，
        // 这是非法的 。
        // 引用型参数应该在能被定义成 const 的情况下，尽量定义为 const。
        ```

10. 顶处理
    C＋＋提供的预处理功能主要有以下 4 种：宏定义 、文件包含、条件编译和布局控制

    ```c
    ＃define area(x) ((x)*(x))

    #define Foo(x) do{\
    statement one;\
    statement two;\
    }while(O)   //这里没有分号

    条件编译命令最常见的形式为：
    #ifdef 标识符
    程序段 l
    #else
    程序段 2
    #endif

    extern ”C”块的作用就是告诉 C＋＋编译器这段代码要按 C 标准编译，以尽可能地保持 C＋＋与 C 的兼容性
    ```